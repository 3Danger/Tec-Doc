// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package abac

import (
	"context"
	"encoding/json"
	goUUID "github.com/google/uuid"
)

type ClientABAC struct {
	*ClientJsonRPC
}

type retABACCheckAccess func(decision bool, err error)

func (cli *ClientABAC) ReqCheckAccess(ret retABACCheckAccess, scope string, featureKey string, userID *uint64, key [16]byte, attributes ...map[string]interface{}) (request baseJsonRPC) {

	request = baseJsonRPC{
		Method: "abac.checkaccess",
		Params: requestABACCheckAccess{
			Attributes: attributes,
			FeatureKey: featureKey,
			Key:        key,
			Scope:      scope,
			UserID:     userID,
		},
		Version: Version,
	}
	var err error
	var response responseABACCheckAccess

	if ret != nil {
		request.retHandler = func(jsonrpcResponse baseJsonRPC) {
			if jsonrpcResponse.Error != nil {
				err = cli.errorDecoder(jsonrpcResponse.Error)
				ret(response.Decision, err)
				return
			}
			err = json.Unmarshal(jsonrpcResponse.Result, &response)
			ret(response.Decision, err)
		}
		request.ID = []byte("\"" + goUUID.New().String() + "\"")
	}
	return
}

func (cli *ClientABAC) CheckAccess(ctx context.Context, scope string, featureKey string, userID *uint64, key [16]byte, attributes ...map[string]interface{}) (decision bool, err error) {

	retHandler := func(_decision bool, _err error) {
		decision = _decision
		err = _err
	}
	if blockErr := cli.Batch(ctx, cli.ReqCheckAccess(retHandler, scope, featureKey, userID, key, attributes...)); blockErr != nil {
		err = blockErr
		return
	}
	return
}
